# 题目

**类型：动态规划**

![img](https://cdn.nlark.com/yuque/0/2022/png/2941598/1665908726142-acc9cff0-b946-4a54-82fe-f83bcaa78b6d.png)





# 解题思路

要找出一个字符串中所有不同的子序列。那么我们就需要找出这种子序列组合的规律。



为了排除其他干扰，假设字符串中素有的字符都是不重复的。



s=“abcd”，那么我们可以看到如下规律：



- 遍历第1个字符`'a'`：子序列总数 = 1（字符'a'本身）= 1
- 遍历第2个字符`'b'`：子序列总数 =【字符'a'的子序列总数】+ 1（字符‘b’本身）= 1 + 1 = 2；
- 遍历第3个字符`'c'`：子序列总数 =【字符'a'的子序列总数】+ 【字符'b'的子序列总数】+ 1（字符‘c’本身）= 1 + 2 + 1 = 4；
- 遍历第4个字符`'d'`：子序列总数 =【字符'a'的子序列总数】+【字符'b'的子序列总数】+【字符'c'的子序列总数】+ 1（字符‘d’本身）= 1 + 2 + 4 + 1 = 8；



【总结果】 = 1 + 2 + 4 + 8 = 15

![img](https://cdn.nlark.com/yuque/0/2022/png/2941598/1665909932034-3f46acd5-38e6-4055-be51-017ac0aa3c92.png)





但是，题目中并没有限制字符不能重复，所以，我们这时候在考虑如果字符串中出现重复字符对结果的影响



以s=“abcb”为例，里面有字符‘b’发生了重复，发现如下规律：



- 在第1次遍历到字符‘b’的时候：子序列为“`ab`”、“`b`”；
- 在第2次遍历到字符‘b’的时候：子序列为“`ab`”、“`b`”、“`abb`”、“`bb`”、“`acb`”、“`abcb`”、“`bcb`”、“`cb`”；



结论：第2次遍历字符'b'的时候，已经包含了第1次遍历字符'b'的子序列了。

所以，在统计最终结果的时候，我们需要把“上一次”相同字符子序列总数减去才可以。



![img](https://cdn.nlark.com/yuque/0/2022/png/2941598/1665910027351-1d9cd78d-083c-47b2-930d-e965df760e92.png)









由于mod的存在，每个变量都不会超过十亿。



假设某个循环中有个pre的值九亿九千万九百九十九万，而此刻result可能只有几十，letters[i]可能只有几百。



此刻他们三个做减法的话就是负的9亿多，这样额外加一个mod可以保证result永远在正数区间。 这个跟二分法中L+R的溢出处理有异曲同工之妙。





# 代码

```java
class Solution {
     public int distinctSubseqII(String s) {
        int mod = (int)1e9 + 7;
        long result = 0L;
        // 记录26个字符每个字符的子序列总数
        long[] letter = new long[26];
        for (char sc : s.toCharArray()) {
            // 获得字符sc前一次统计的子序列数
            long pre = letter[sc - 'a'];
            // 计算当前字符sc的子序列数
            letter[sc - 'a'] = (result + 1) % mod;
            // 加mod的目的是为了防止结果溢出为负数
            result = (result + letter[sc - 'a'] - pre + mod) % mod; 
        }
        return (int)result;
    }
}
```